\chapter{Форирование ключевых подходов к CI/CD и подготовка к миграции} \label{ch:ch2}

\section{Анализ и кластеризация репозиториев к переносу} \label{sec:repository-analysis}
Для стандартизации конвейеров и оптимизации работы через GitLab REST API\cite{gl-rest-api} был получен список репозиториев компании.
Далее был написан скрипт,
который на основе названия репозитория (часть имела префикс, указывавший на тип репозитория) и использовавшихся в нем компонентов в GitHub Action,
определял, к какой категории данный репозиторий принадлежит.
Для репозиториев, у которых не получилось автоматически определить их тип, анализ выполнялся вручную.
По результатам анализа удалось выделить 26 кластеров, далее описаны некоторые из них:
\begin{itemize}
  \item Custom — репозиторий с уникальными пайплайнами, требующие отдельного подхода к переносу.
        В основном в эту категорию попадали старые большие проекты компании;
  \item CSharpLib — C\# библиотека со стандартизованными пайплайнами;
  \item CSharpLibNotTemplate — C\# библиотека с не стандартизованными пайплайнами;
  \item Microservice — C\# микросервис, использующий стандартизованные пайплайны;
  \item MicroFrontend — микрофронтенд;
  \item CopyOnly — репозиторий без CI/CD шаблонов, который можно просто скопировать;
  \item GitLeaksOnly — репозиторий, содержащий только стандартизированный gitleaks пайплайн.
\end{itemize}

\section{GitLab Components} \label{sec:gl-components}
В рамках миграции CI/CD пайплайнов с GitHub на GitLab одним из ключевых решений стало использование компонентов
для обеспечения переиспользования логики конвейеров и той самой стандартизации.
Данная секция посвящена рассмотрению компонентов как фундаментального элемента организации CI/CD процессов в GitLab.

\subsection{Назначение и роль компонентов} \label{subsec:components-role}
Компоненты в GitLab CI/CD\cite{gl-components} представляют собой механизм для создания переиспользуемых блоков конфигурации конвейеров.
Основная цель их применения заключается в стандартизации и упрощении процесса создания новых пайплайнов,
особенно для типовых сценариев, таких как развертывание микросервисов или сборка библиотек.
Компоненты служат заменой шаблонных файлов конфигурации, которые активно использовались в GitHub Actions.
В отличие от простого копирования конфигураций, компоненты предоставляют параметризованный подход,
позволяющий настраивать поведение пайплайна через входные параметры без необходимости дублирования кода.

\subsection{Принцип работы компонентов} \label{subsec:components-work-principals}
Механизм функционирования компонентов основан на принципе подстановки параметров и копирования кода.
При использовании компонента GitLab выполняет следующие операции:
\begin{enumerate}
  \item Обработка входных параметров — система анализирует переданные параметры и выполняет их валидацию согласно спецификации компонента;
  \item Подстановка значений — происходит замена шаблонов в коде компонента на соответствующие значения параметров;
  \item Интеграция в конвейер — обработанный код компонента включается в итоговую конфигурацию пайплайна.
\end{enumerate}

\subsection{Хранение компонентов} \label{subsec:components-storage}
Компоненты должны храниться в специализированных GitLab репозиториях, путь к ним должен выглядеть следующим образом:
\begin{verbatim}
$CI_SERVER_FQDN/system/components/[component-name]
\end{verbatim}

Отчасти навязывание подобной структуры удобно: знания о такой организации описаны в документации GitLab,
не будет необходимости дополнительно обучать сотрудников, как работают конвейеры в компании.

\section{Проектирование приложения мигратора} \label{sec:gitlab-migrator-app}

Определив типы репозиториев и разобравшись с организацией работы CI/CD в GitLab, команда приступила к проектированию инструмента переноса.
Основная его цель — предоставить группе разработчиков отлаженный и понятный процесс,
который позволит мигрировать репозитории с минимальным (желательно нулевым) простоем для отдела разработки.

Логично, чтобы автоматизировать этот процесс, его сначала надо тоже спроектировать.
По итогу команда пришла к алгоритму, состоявшему из трех фаз:
\begin{enumerate}
  \item Репозиторий-черновик.
        На этой фазе первым делом должна оповещаться команда, закрепленная за проектом, чтобы она не изменяла существующие конвейеры в GitLab.
        Далее в GitLab должен создаваться клон-репозиторий с постфиксом \texttt{-ci-cd}.
        В нем будет создаваться ветка (ее назвали \texttt{test\_branch}), в которую будут вноситься изменения по адаптации к GitLab, например, те конвейеры.
        По создании запроса на слияния тестовой ветки в репозитории черновике работа приложения должна блокироваться до ручного вмешательства разработчика.
        Он должен вручную внести все изменения, не поддающиеся автоматизации, а затем подтвердить, что можно продолжить.
  \item Защита от ошибок.
        Вторая фаза должна выполнять проверки по внесенным изменениям: успешно ли завершаются конвейеры, есть ли внешние ссылки в GitHub,
        на которые стоит обратить внимание и доработать в \texttt{test\_branch} перед переходом на следующий шаг.
  \item Полный перенос.
        Эта фаза будет отвечать за окончательный перенос: полный перенос репозитория вместе с внесенными на прошлом шаге адаптациями.
        На этом этапе как раз будет использован ранее упомянутый инструмент импорта от GitLab (глава ~\ref{subsec:official-migration-instruments}).
        По окончании переноса ответственная за репозиторий команда будет оповещаться об успешном завершении миграции.
\end{enumerate}

Далее во время реализации каждая фаза будет разбита на шаги для удобства поддержания кода, а также для его гибкости,
в случае если надо будет добавить дополнительную операцию в одну из фаз.

Вдохновившись эпизодом\cite{podlodka-podcast} подкаста подлодка,
где Кирилл Мокевнин рассказывал про элегантность конечных автоматов\cite{fsm} для описания сложных бизнес процессов,
команда решила смотреть на архитектуру приложения-мигратора именно в этом ключе:
перенос будет определяться ограниченным набором состояний с переходом между ними.
Тут же возникает следующая проблема — процесс переноса может прерваться либо из-за внутренней ошибки приложения, либо из-за неполадок на внешних сервисах.
Есть разные способы устранения данной сложности, однако в случае с мигратором был выбран подход возможности восстановления работы с места, где прекратилось выполнение.
Для этого надо было предусмотреть две вещи:
\begin{itemize}
  \item Сохранение текущего состояния (в данном случае шага).
        Изначально планировалось использовать базу данных для этих целей, однако потом был выбран \texttt{Configuration-as-Code} подход\cite{cac}.
        Для миграции должен быть создан единый файл, содержащий список всех репозиториев вместе с прошедшими шагами переноса.
        Таким образом, сразу в GitLab можно было бы отслеживать прогресс миграции.
        К тому же таким решением несильно, но были снижены расходы на миграцию: база данных дороже, чем файл в репозитории.
  \item Идемпотентность\cite{idempotence}.
        Шаг может прерваться в любой момент.
        Не всегда получится сделать его максимально атомарным, без побочных эффектов.
        Именно поэтому в каждый шаг должен уметь выполняться без дублирования операции, если она уже была ранее выполнена.
\end{itemize}
